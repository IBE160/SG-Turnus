from pydantic import BaseModel, EmailStr, ConfigDict # Added ConfigDict
from enum import Enum
from typing import Optional, Dict, Union, List
import datetime
from backend.app.core.ai.flashcard_generation_module import Flashcard
from backend.app.core.ai.quiz_generation_module import QuizQuestion
from backend.app.models.planner import NextStep

class UserRegistration(BaseModel):
    email: EmailStr
    password: str

class UserResponse(BaseModel):
    user_id: str
    email: EmailStr

class VerifyEmailRequest(BaseModel):
    email: EmailStr
    token: str

class LoginRequest(BaseModel):
    email: EmailStr
    password: str

class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"

class CalibrationQuestionResponse(BaseModel):
    """
    Structured response for a calibration question.
    """
    type: str = "calibration_question"
    question: str

class ExploratoryPhrasingResponse(BaseModel):
    """
    Structured response for an exploratory phrasing.
    """
    type: str = "exploratory_phrasing"
    phrasing: str

class ClarityResponse(BaseModel):
    """
    Represents the AI's response after processing a user's query,
    including the action to be taken and the content of the response.
    The 'content' field can be a direct string or a structured object
    like CalibrationQuestionResponse or ExploratoryPhrasingResponse.
    """
    action: str # e.g., "direct_response", "uncertainty_handling", "generate_materials"
    content: Union[str, CalibrationQuestionResponse, ExploratoryPhrasingResponse, NextStep]

class StudyMaterialCreate(BaseModel):
    file_name: str
    s3_key: str

class StudyMaterialResponse(BaseModel):
    id: int
    user_id: int
    file_name: str
    s3_key: str
    upload_date: datetime.datetime
    processing_status: str
    generated_summaries: List['GeneratedSummaryResponse'] = []
    generated_flashcard_sets: List['GeneratedFlashcardSetResponse'] = []
    generated_quizzes: List['GeneratedQuizResponse'] = []

    class Config:
        orm_mode = True # Updated Pydantic V2 syntax

class StudyMaterialUpdate(BaseModel):
    file_name: Optional[str] = None
    s3_key: Optional[str] = None
    processing_status: Optional[str] = None

class NLPRequest(BaseModel):
    text: str

class NLPSignalsResponse(BaseModel):
    lexical_signals: Dict
    structural_signals: Dict
    content_density: Dict

class SummarizeRequest(BaseModel):
    text: str
    detail_level: Optional[str] = "normal"

class SummarizeResponse(BaseModel):
    summary: str

class FlashcardGenerateRequest(BaseModel):
    text: str
    # Optional fields like num_flashcards or difficulty can be added later

class FlashcardGenerateResponse(BaseModel):
    flashcards: List[Flashcard]

class QuizGenerateRequest(BaseModel):
    text: str

class QuizGenerateResponse(BaseModel):
    questions: List[QuizQuestion]

class ExportRequest(BaseModel):
    content: str
    format: str

# New schemas for persistent generated materials
class GeneratedSummaryResponse(BaseModel):
    id: int
    study_material_id: int
    content: str
    detail_level: Optional[str]
    generated_at: datetime.datetime

    class Config:
        orm_mode = True # Updated Pydantic V2 syntax

class GeneratedFlashcardResponse(BaseModel):
    question: str
    answer: str

class GeneratedFlashcardSetResponse(BaseModel):
    id: int
    study_material_id: int
    content: List[GeneratedFlashcardResponse]
    generated_at: datetime.datetime

    class Config:
        orm_mode = True # Updated Pydantic V2 syntax

class GeneratedQuizQuestionResponse(BaseModel):
    question: str
    options: List[str]
    correct_answer: str

class GeneratedQuizResponse(BaseModel):
    id: int
    study_material_id: int
    content: List[GeneratedQuizQuestionResponse]
    generated_at: datetime.datetime

    class Config:
        orm_mode = True # Updated Pydantic V2 syntax

class Permissions(str, Enum):
    view_only = "view_only"
    edit = "edit"

class ShareCreateRequest(BaseModel):
    study_material_id: int
    shared_with_email: Optional[EmailStr] = None # If sharing with a specific user
    permissions: Permissions = Permissions.view_only
    expires_at: Optional[datetime.datetime] = None

class SharedMaterialResponse(BaseModel):
    id: int # id of the SharedStudyMaterial entry
    study_material_id: int
    file_name: str # from StudyMaterial
    s3_key: str # from StudyMaterial
    shared_by_user_id: int
    shared_with_user_id: Optional[int] = None
    share_token: Optional[str] = None
    permissions: Permissions
    created_at: datetime.datetime
    expires_at: Optional[datetime.datetime] = None

    class Config:
        orm_mode = True # Updated Pydantic V2 syntax

class SharedLinkResponse(BaseModel):
    share_token: str
    full_share_url: str # This will be generated by the frontend using the token
    permissions: Permissions
    expires_at: Optional[datetime.datetime] = None

class FeedbackCreate(BaseModel):
    material_id: int
    material_type: str
    rating: int
    comments: Optional[str] = None

class FeedbackResponse(BaseModel):
    id: int
    user_id: int
    material_id: int
    material_type: str
    rating: int
    comments: Optional[str] = None
    created_at: datetime.datetime

    class Config:
        orm_mode = True # Updated Pydantic V2 syntax

# Add update_forward_refs() to handle forward references after all classes are defined
StudyMaterialResponse.update_forward_refs()