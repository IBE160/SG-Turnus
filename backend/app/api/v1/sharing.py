from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from backend.app.database import get_db
from backend.app.models.study_material import StudyMaterial
from backend.app.models.user import User
from backend.app.models.shared_study_material import SharedStudyMaterial
from backend.app.dependencies import get_current_user
from backend.app.api.schemas import ShareCreateRequest, SharedMaterialResponse, SharedLinkResponse, Permissions
from sqlalchemy import or_

router = APIRouter(
    prefix="/sharing",
    tags=["sharing"],
    responses={404: {"description": "Not found"}},
)

@router.post("/share", response_model=SharedMaterialResponse, status_code=status.HTTP_201_CREATED)
async def create_share(
    share_request: ShareCreateRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Creates a new share entry for a study material. Can be a direct share with a user or a shareable link.
    """
    db_study_material = db.query(StudyMaterial).filter(
        StudyMaterial.id == share_request.study_material_id,
        StudyMaterial.user_id == current_user.id
    ).first()

    if not db_study_material:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Study material not found or user does not own it"
        )

    shared_with_user_id: Optional[int] = None
    share_token: Optional[str] = None

    if share_request.shared_with_email:
        shared_with_user = db.query(User).filter(User.email == share_request.shared_with_email).first()
        if not shared_with_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"User with email {share_request.shared_with_email} not found"
            )
        shared_with_user_id = shared_with_user.id
    else:
        # If no specific user, generate a shareable link
        # The share_token is generated by default in the model
        pass

    db_share = SharedStudyMaterial(
        study_material_id=share_request.study_material_id,
        shared_by_user_id=current_user.id,
        shared_with_user_id=shared_with_user_id,
        permissions=share_request.permissions.value,
        expires_at=share_request.expires_at
    )
    db.add(db_share)
    db.commit()
    db.refresh(db_share)

    # Attach file_name and s3_key for the response
    response_data = db_share.__dict__
    response_data['file_name'] = db_study_material.file_name
    response_data['s3_key'] = db_study_material.s3_key

    return SharedMaterialResponse(**response_data)

@router.get("/material/{share_token}", response_model=SharedMaterialResponse)
def get_shared_material_by_token(
    share_token: str,
    db: Session = Depends(get_db)
):
    """
    Allows access to a shared material via a public share token.
    No authentication required for this endpoint, but the token must be valid and not expired.
    """
    db_share = db.query(SharedStudyMaterial).filter(
        SharedStudyMaterial.share_token == share_token,
        or_(SharedStudyMaterial.expires_at >= datetime.datetime.utcnow(), SharedStudyMaterial.expires_at == None)
    ).first()

    if not db_share:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Shared material not found or link has expired"
        )
    
    db_study_material = db.query(StudyMaterial).filter(StudyMaterial.id == db_share.study_material_id).first()
    if not db_study_material:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Original study material not found"
        )

    response_data = db_share.__dict__
    response_data['file_name'] = db_study_material.file_name
    response_data['s3_key'] = db_study_material.s3_key

    return SharedMaterialResponse(**response_data)

@router.get("/my-shares", response_model=List[SharedMaterialResponse])
def get_my_shares(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Retrieves a list of study materials shared by the current user.
    """
    shares = db.query(SharedStudyMaterial).filter(
        SharedStudyMaterial.shared_by_user_id == current_user.id
    ).all()

    response_list = []
    for share in shares:
        db_study_material = db.query(StudyMaterial).filter(StudyMaterial.id == share.study_material_id).first()
        if db_study_material:
            response_data = share.__dict__
            response_data['file_name'] = db_study_material.file_name
            response_data['s3_key'] = db_study_material.s3_key
            response_list.append(SharedMaterialResponse(**response_data))
    return response_list

@router.get("/shared-with-me", response_model=List[SharedMaterialResponse])
def get_shared_with_me(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Retrieves a list of study materials shared with the current user.
    """
    shares = db.query(SharedStudyMaterial).filter(
        SharedStudyMaterial.shared_with_user_id == current_user.id
    ).all()

    response_list = []
    for share in shares:
        db_study_material = db.query(StudyMaterial).filter(StudyMaterial.id == share.study_material_id).first()
        if db_study_material:
            response_data = share.__dict__
            response_data['file_name'] = db_study_material.file_name
            response_data['s3_key'] = db_study_material.s3_key
            response_list.append(SharedMaterialResponse(**response_data))
    return response_list

@router.delete("/{share_id}", status_code=status.HTTP_204_NO_CONTENT)
def revoke_share(
    share_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Revokes a specific share, effectively making the material no longer shared.
    Only the owner of the share can revoke it.
    """
    db_share = db.query(SharedStudyMaterial).filter(
        SharedStudyMaterial.id == share_id,
        SharedStudyMaterial.shared_by_user_id == current_user.id
    ).first()

    if not db_share:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Share not found or user is not the owner"
        )
    
    db.delete(db_share)
    db.commit()
    return